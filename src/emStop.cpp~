#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <sensor_msgs/LaserScan.h>
#include <nav_msgs/Odometry.h>
#include <geometry_msgs/Twist.h>
#include "opencv2/core/core.hpp"
#include <math.h>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


int w=600;
int h=600;
cv::Mat imm=cv::Mat(w,h,CV_8U);
cv::Mat immTot=cv::Mat(w,h*2,CV_8U);

float resolution=.05;

int size=0;
float angle_min=0;
float angle_incr=0;
float ranges[1081];
float robot_posx=0;
float robot_posy=0;
float robot_orient=3.14;
ros::Time time_stamp;

float posx;
float posy;
int indx;
int indy;

int maskSize = CV_DIST_MASK_PRECISE;
int distType = CV_DIST_L2;
cv::Mat dist;

cv::Mat grad_x, grad_y;
cv::Mat grad;
int scale = 100;
int delta = 0;
int ddepth = CV_16S;

geometry_msgs::Twist joy_command_vel;
geometry_msgs::Twist key_command_vel;
geometry_msgs::Twist command_vel;

int distanza_saturazione_cm= 50;
float grandezza_robot=.35;// .35;
float pixel_robot=(grandezza_robot/resolution)*(grandezza_robot/resolution);
float distanza_saturazione=distanza_saturazione_cm/100.f;
float n_pixel_sat=(distanza_saturazione+(grandezza_robot/2))/resolution;
float intensita_repulsive_force=distanza_saturazione+(grandezza_robot/2);
int force_scale_cent=20;
float force_scale=(force_scale_cent/1000.f)/(pixel_robot/2);

int momentum_scale_mill=25;
float momentum_scale=(momentum_scale_mill/1000.f)/(pixel_robot/2);

int sizematforze=round(grandezza_robot/resolution);
cv::Mat matriceForze(sizematforze,sizematforze,CV_32FC3);

template<typename T>
T sign(T In)
{
    if(In<(T)-0)
        return -1;
    return 1;
}


void callbackSensore(const sensor_msgs::LaserScan::ConstPtr& msg)
{	
	size=msg->ranges.size();
	angle_min=msg->angle_min;
	angle_incr=msg->angle_increment;
	time_stamp=msg->header.stamp;
	memcpy(&ranges,&msg->ranges,size*sizeof(float));	
}

void callbackKeyboardInput(const geometry_msgs::Twist::ConstPtr& msg)
{	
	key_command_vel.linear=msg->linear;
	key_command_vel.angular=msg->angular;	
}

void callbackJoystickInput(const geometry_msgs::Twist::ConstPtr& msg)
{	
	joy_command_vel.linear=msg->linear;
	joy_command_vel.angular=msg->angular;	
}


void costruisciScanImage(){
	imm = cv::Scalar(255);
	posx=0; posy=0; indx=0; indy=0;	
	for(int i = 0; i < size; i++){
		posx=ranges[i]*cos(angle_min+(i*angle_incr));
		posy=ranges[i]*sin(angle_min+(i*angle_incr));
		indy=-round((posy/resolution)-h/2);
		indx=round(-(posx/resolution)+w/2);
		if(indx>=0&&indx<w && indy>=0&&indy<h){
			imm.at<uchar>(indx,indy)=0;
		}
	}
	imm.at<uchar>(h/2,w/2)=255;
	int size=round(grandezza_robot/resolution);
	for (int i=-size/2;i<size/2;i++){
		for (int j=-size/2;j<size/2;j++){
			imm.at<uchar>(h/2+i,w/2+j)=100;
		}
	}
}


void costruisciDistanceImage(){
	cv::distanceTransform( imm, dist, distType, maskSize );
	dist *= 1.f/n_pixel_sat; //1 su n pixel per la saturazione
	cv::pow(dist, .5, dist);
	for(int i=0;i<dist.rows;i+=1){
		for(int j=0;j<dist.cols;j+=1){
			if(dist.at<float>(i,j)>1.f){
				dist.at<float>(i,j)=1.f;
			}
		}
	}
}


void costruisciGradientImage(){

	/// Generate grad_x and grad_y
	cv::Mat abs_grad_x, abs_grad_y;
	 //cvtColor( dist, src_gray, CV_RGB2GRAY );
	
	/// Gradient X
	cv::Scharr( dist, grad_x, ddepth, 1, 0, scale, delta, cv::BORDER_DEFAULT );
	//Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );
	//printf("gradx= %d",grad_x.at<short>(h/2,w/2));
	cv::convertScaleAbs( grad_x, abs_grad_x );
	

	/// Gradient Y
	cv::Scharr( dist, grad_y, ddepth, 0, 1, scale, delta, cv::BORDER_DEFAULT );
	//Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );
	//printf("grady= %d\n",grad_y.at<short>(h/2,w/2));
	cv::convertScaleAbs( grad_y, abs_grad_y );

	/// Total Gradient (approximate)
	cv::addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );
	//printf("grad= %i\n",grad.at<uchar>(h/2,w/2));

	cv::Mat grad_x_rid=grad_x(cv::Range(h/2-(sizematforze)/2,h/2+(sizematforze)/2), cv::Range(w/2-(sizematforze)/2,w/2+(sizematforze)/2));
	cv::Mat grad_y_rid=grad_y(cv::Range(h/2-(sizematforze)/2,h/2+(sizematforze)/2), cv::Range(w/2-(sizematforze)/2,w/2+(sizematforze)/2));
	
	/// costruzione matrice forze
	for(int i=0;i<sizematforze;i++){
		for(int j=0;j<sizematforze;j++){
			matriceForze.at<cv::Vec3f>(i,j)=cv::Vec3f(grad_x_rid.at<short>(i,j),grad_y_rid.at<short>(i,j),0);
		}
	}
	
}


void onTrackbarSaturazione( int, void* ){
	distanza_saturazione=distanza_saturazione_cm/100.f;
	n_pixel_sat=(distanza_saturazione+(grandezza_robot/2))/resolution;
}

void onTrackbarForceScaling( int, void* ){
	force_scale=(force_scale_cent/1000.f)/(pixel_robot/2);
}

void onTrackbarMomentumScaling( int, void* ){
	momentum_scale=(momentum_scale_mill/1000.f)/(pixel_robot/2);
}


void affiancaImmagini(cv::Mat& imm1, cv::Mat& imm2, cv::Mat& immris){
	for (int i=0;i<h;i++){
		for(int j=0;j<w;j++){
			immris.at<uchar>(i,j)=imm1.at<uchar>(i,j);
		}
	}
	for (int i=0;i<h;i++){
		for(int j=0;j<w;j++){
			immris.at<uchar>(i,j+w)=imm2.at<uchar>(i,j);
		}
	}
}


void calcolaMomentoeForza(cv::Mat& forze, cv::Vec3f& momento, cv::Vec3f& forza){
	cv::Vec3f momtemp(0,0,0);
	cv::Vec3f forzatemp(0,0,0);
	cv::Vec3f f(0,0,0);
	float dist=1;
	cv::Vec3f b(0,0,0);
	for (int i=0;i<forze.cols;i++){
		for (int j=0; j<forze.rows;j++){
			f=forze.at<cv::Vec3f>(j,i);
			if(f!=cv::Vec3f(0,0,0)&&(i!=forze.rows/2 && j!=forze.rows/2)){
				dist=abs(i-forze.rows/2)+abs(j-forze.rows/2);
				//dist=std::max(abs(i-h/2),abs(j-w/2));
				if(j<=forze.rows/2){
					b[0]=-(-i+forze.rows/2); b[1]=-(j-forze.rows/2);
					momtemp+=b.cross(f);
				}
			}
			if(f!=cv::Vec3f(0,0,0)){
				forzatemp[0]+=f[0]; forzatemp[1]+=f[1];
			}
		}
	}
	momento=momtemp;
	forza=forzatemp;
} 


int main(int argc, char **argv)
{

  	ros::init(argc, argv, "emergencyStop");


  	ros::NodeHandle n;

	ros::Publisher pub = n.advertise<geometry_msgs::Twist>("cmd_vel", 1);
	
	ros::Subscriber sub3 = n.subscribe("/ps3joy_cmd_vel", 1, callbackJoystickInput);

	ros::Subscriber sub2 = n.subscribe("/keyboard_cmd_vel", 1, callbackKeyboardInput);

	ros::Subscriber sub = n.subscribe("/base_scan", 1, callbackSensore);
	
	cv::namedWindow("GUI", 1);
	cv::createTrackbar("Raggio d'influenza (cm)", "GUI", &distanza_saturazione_cm, 200, onTrackbarSaturazione, 0);
	cv::createTrackbar("Repulsive Force Scale", "GUI", &force_scale_cent, 1000, onTrackbarForceScaling, 0);
	cv::createTrackbar("Repulsive Momentum Scale", "GUI", &momentum_scale_mill, 1000, onTrackbarMomentumScaling, 0);


	int fps=60;
	ros::Rate loop_rate(fps);
	ros::AsyncSpinner spinner(8); // n threads
	spinner.start();
	tf::Vector3 axis;

	ros::Time old_time=ros::Time::now();
	ros::Time current_time=ros::Time::now();
	ros::Duration deltat=current_time-old_time;
	double dt=deltat.sec+(deltat.nsec/1000000000.f);
	float repulsive_linear_acc=0;
	float repulsive_angular_acc=0;
	cv::Vec3f forza;
	cv::Vec3f momento;
		
	while(n.ok()){
		
		/**** Creazione immagini **********************/
		costruisciScanImage();
		costruisciDistanceImage();
		costruisciGradientImage();
		affiancaImmagini(imm,grad,immTot);

		//cv::imshow("Gradient",grad);
		//cv::imshow("Laser Scan",imm);
		cv::imshow("Distance map",dist);
		cv::imshow("GUI",immTot);
		/*************************************************/
		
		repulsive_linear_acc=0;
		repulsive_angular_acc=0;		

		calcolaMomentoeForza(matriceForze,momento,forza);
		if((grad_x.at<short>(h/2,w/2)!=0||grad_y.at<short>(h/2,w/2)!=0)&&forza[1]>0){
			repulsive_linear_acc=forza[1];		
			repulsive_angular_acc=momento[2];
		}		
		
		
		old_time=current_time;
		current_time=ros::Time::now();
		deltat=current_time-old_time;
		dt=deltat.sec+(deltat.nsec/1000000000.f);
		
		command_vel=joy_command_vel;
		if (joy_command_vel.linear.x==0 && joy_command_vel.angular.z==0){
			command_vel=key_command_vel;
		}
		if(command_vel.linear.x!=0){	
			command_vel.linear.x-=force_scale*repulsive_linear_acc*dt;
			command_vel.angular.z+=momentum_scale*repulsive_angular_acc*dt;
		}
		printf("acc %f %f \n",force_scale*repulsive_linear_acc,momentum_scale*repulsive_angular_acc);		
		
		pub.publish(command_vel);

		cv::waitKey(1000/fps);
		loop_rate.sleep();
	}

	spinner.stop();
	return 0;
}



